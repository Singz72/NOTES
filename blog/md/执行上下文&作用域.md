# 执行上下文&作用域

## 执行上下文

> JavaScript标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”

js代码执行时，都是在这样的环境中执行的，执行时创建，执行完便销毁

执行上下文类型：

+ 全局执行上下文：默认或者基础的上下文，任何不在函数内部的代码都存在于全局执行上下文中，他会创建一个window（global）的全局对象，并将this赋予这个全局对象。一个程序将会只包含一个全局执行上下文
+ 函数执行上下文：函数在被调用时创建的一个上下文，是这个函数拥有的属于其自己的上下文；该种上下文可以有多个，因为会存在有多个函数被调用，当函数被释放（调用完/销毁）后，其上下文也会被释放
+ Eval执行上下文：eval函数内部代码也拥有一个执行上下文


## 执行栈

> 用来存储和管理js代码执行时创建的执行上下文的一种数据结构。

执行栈有着后进先出的原则。
js引擎在执行js代码时，会创建一个全局执行上下文并压入执行栈，每当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈，直到执行完所有的代码，最后弹出全局执行上下文。其中，当分配的执行栈空间被占满时，会引发“堆栈溢出”。

## 创建执行上下文

执行上下文包括：

+ lexical environment：词法环境，储存函数声明、const和let声明的变量和this值
+ variable environment：变量环境，储存var声明的变量

知道怎么管理执行上下文，就应该知道执行上下文是怎么创建的，创建执行上下文会发生以下几件事：

+ 创建词法环境组件
+ 创建变量环境组件

### 词法环境

> 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

简单理解就是一种键值对的映射，能够存储变量和函数声明的实际位置（代码中的位置），并有一个属性outer，作为访问父级词法环境的标示（作用域），及一个ThisBinding属性，记录当前的this引用

根据执行上下文，词法环境也可以分为：

+ 全局词法环境：outer属性为null，拥有内建的各种构造函数（Object、Array等）、原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且`this`的值指向全局对象。
+ 函数词法环境：函数内部用户自定义的变量或者函数，outer为全局词法环境或者包含该函数的函数环境，this在创建时指向其引用

### 变量环境

变量环境也是一种词法环境，但是在ES6之后，和词法环境不同的是，变量环境只是用来存储var声明的变量

举个例子

```js
var a = 'a'
let b = 'b'
const c = 'c'

function A(){
    var d = 'd'
    let e = 'e'
    const f = 'f'
    function B(){}
}

A()
```

根据这段代码，写一个伪代码来表示词法环境和变量环境的形式：
js引擎要执行js代码，先创建全局执行上下文，并创建对应的词法环境和变量环境，压入执行栈，引擎开始执行相关代码，当遇到`A()`时，创建函数A的执行上下文，也创建对应的词法和变量环境，压入执行栈，并开始执行该函数

![执行栈](http://singz72.com/images/blog/context.png)



## 作用域链

作用域就是变量和函数的可访问区域，即作用域控制着变量和函数的可见性和生命周期。

作用域包括：

+ 全局作用域
+ 函数作用域
+ 块级作用域

每个执行上下文都有一个属性outer，来指向它外部的执行上下文，在我们执行一段js代码时，需要使用某个变量或者函数时，就会在当前执行上下文中寻找该变量或者函数，那么如果在当前的环境中没能找到对应的变量或者函数，就需要从他的外部执行上下文寻找，直到最外层为null。其中存在着上下文的切换，我们是靠所在当前上下文的outer属性来决定方向的，而outer指向的便是外层上下文，这个方向，便是作用域链的方向。

举个例子

```js
const a = 1

function A(){
    const b = 2
    const c = a + b
    B()
}

function B(){
    const d = 3
    console.log(a + d)
    console.log(c)
}

A()
```

大概执行思路如下：

1. 执行js代码，创建全局上下文，压入执行栈，直到A函数被调用
2. 创建A函数的执行上下文，压入执行栈列表

   ```js
   执行栈列表：
   - global
   - A()
   ```

3. 执行A函数中所有代码：
   1. 在变量c的初始化过程中，需要获取a的值
   2. 从当前上下文中寻求a的值
   3. 未能找到a的值，读取outer属性值切换上下文，进入outer指向的上下文
   4. 在外层上下文中获取到a的值，返回自己的上下文
4. 代码执行到B()
5. 创建B函数的执行上下文，压入执行栈列表

   ```js
   执行栈列表：
   - global
   - A()
   - B()
   ```

6. 执行B函数中所有代码，直到全部执行完毕：
   1. 获取a的变量
   2. 从当前上下文中寻求a的值
   3. 未能找到a的值，读取outer属性值切换上下文，进入outer指向的上下文
   4. 在外层上下文中获取到a的值，返回自己的上下文
   5. 获取c的变量
   6. 重复寻求a变量的步骤
   7. 在外层上下文中未能获取到c的值，读取外层上下文outer属性值切换上下文，但因为外层上下文的outer为null，停止切换
   8. 未能成功获取到c的值，报错，停止代码的执行
7. 假设B函数成功执行完毕，从执行栈中删除B()

   ```js
   执行栈列表：
   - global
   - A()
   ```

8. 返回A函数，执行B()后的代码，直到全部执行完毕
9. 从执行栈中删除A()

   ```js
   执行栈列表：
   - global
   ```

10. 返回到调用A()的代码行，继续执行其后的代码，直到执行完毕
11. 删除全局上下文
12. 清空执行栈

![执行栈](http://singz72.com/images/blog/scope.png)

所以，可以理解得到，作用域的块儿和他的外部环境由在编写程序时的位置决定的，其中的切换上下文是按照作用域链的顺序来查找的，而不是按照执行栈由外到里的顺序来的

补充一下和上下文以及作用域有关联的知识点

## 闭包

闭包就是函数和函数内部能访问到的变量的总和

通过闭包，我们能够隐藏变量，还能访问不能访问到的作用域

## this

不管函数从哪里被调用，也不论它是如何被调用，它的词法作用域是由这个函数被声明时的位置唯一决定的

ps：关于this的指向，在函数定义时是确定不了this的指向的，只能确定他的作用域，this的指向是由该函数被调用时决定的，可以理解为，谁最终调用函数，this指向谁

1. 调用函数时使用的引用，决定了函数执行时刻的 this 值。
2. this指向的，永远只可能是对象
3. 通过函数名()直接调用，不论所在作用域是什么，该被调用this都指向window
4. 剪头函数没有thisbinding属性

判定this方法：

1. 函数是通过new被调用的吗（new绑定）

   如果是，this就是新构建的实例对象，且无法改动。

    ```js
    var bar = new foo(); //bar
    ```

2. 函数是通过 call 或 apply 被调用的么（明确绑定），甚至是隐藏在bind硬绑定之中吗？

    如果是，this就是那个被明确指定的对象。

    ```js
    var bar = foo.call(obj2); //obj2
    ```

3. 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this就是那个环境对象。

    ```js
    var bar = obj1.foo(); //obj1
    ```

4. 否则，使用默认的this。如果在strict mode下，就是undefined，否则就是global对象。

    ```js
    var bar = foo(); //window
    ```

5. 箭头函数

    箭头函数中使用的this由包裹该箭头函数所处的环境决定

    ```js
    const func1 = function(){
    const func2 = () => {
        console.log(this.name);//FUNC
    }
    setTimeout(func2,1000);
    }
    func1.call({name:'FUNC'})
    const obj = {
        a: 'obj',
        f: () => {
            console.log(this)
        }
    }
    const func3 = obj.f;
    func3();//window
    ```
