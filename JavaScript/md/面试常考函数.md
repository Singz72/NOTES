# 面试常考函数

## 防抖-debounce

### 描述

> 频繁触发事件时，仅在事件触发间隔超过规定间隔时，事件才会有效执行

### 应用场景

- 输入框中搜索内容时，为了减少服务器压力，在用户停止搜索一定时间后再触发请求查询内容
- 频繁改变窗口大小时，在用户停止改变一定时间后再触发相应事件

### 常用版本

```js
/**
 * @param {Function} 需要防抖处理的函数
 * @param {number} 时间间隔
 * @return {Function} 被防抖处理的函数
 */
function debounce(fn, delay) {
  let timer;
  return function (...arg) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(undefined, arg);
      timer = null;
    }, delay);
  };
}
```

### 进阶版本

```js
/**
 * @param {Function} 需要防抖处理的函数
 * @param {number} 时间间隔
 * @param {boolean} 若为 true，表示计时器开始计时时立即执行；若为false，默认值，表示计时器计时结束时执行
 * @return {Function} 被防抖处理的函数
 */
function debounce(fn, delay, immediate = false) {
  let timer;
  return function (...arg) {
    let context = this;
    if (timer) clearTimeout(timer);
    if (immediate) {
      const callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);
      if (callNow) fn.apply(context, arg);
    } else {
      timer = setTimeout(() => {
        fn.apply(context, arg);
        timer = null;
      }, delay);
    }
  };
}
```

### React Hooks 版本

hooks 在每次 state 变化时，便会执行整个组件，相对于普通情况下闭包的方法，这里会造成 timer 在 hooks 每次执行时被重置，所以需要对 timer 进行特殊处理，防止其引用变化，需要用到 useRef 来保存 timer，以便于我们在未来可以使用到过去的值（逆潮而行）

```js
/**
 * @param {Function} 需要节流处理的函数
 * @param {number} 时间间隔
 * @return {Function} 被节流处理的函数
 */
function useDebounce(fn, delay) {
  const { current } = useRef({});

  const fnc = function (...arg) {
    if (current.timer) clearTimeout(current.timer);
    current.timer = setTimeout(() => {
      fn.apply(undefined, arg);
      current.timer = null;
    }, delay);
  };

  return fnc;
}
```

## 节流-throttle

### 描述

> 触发事件后，在指定时间间隔内，该事件只会执行一次

### 应用场景

- 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取
- 提交按钮

### 常用版本

```js
function throttle(fn, delay) {
  let timer;
  return function (...arg) {
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
      }, delay);
      fn.apply(undefined, arg);
    }
  };
}
```

### React Hooks 版本

```js
function useThrottle(fn, delay) {
  const { current } = useRef;

  const fnc = function (...arg) {
    if (!current.timer) {
      current.timer = setTimeout(() => {
        current.timer = null;
      });
      fn.apply(undefined, arg);
    }
  };

  return fnc;
}
```

## 构造函数

### 构造函数的返回值

#### 描述

当构造函数返回引用类型的数据时，创建的'实例'将会是该类型的数据，而非该构造函数生成的实例（可以通过instanceof来判断，或者在原型上加属性或者方法来判断）

```js
function Car() {
  this.wheel = 4;
  return { wheel: 2 };
}
const car = new Car();
console.log(car.wheel); // 2
```

其他的引用类型数据，比如数组、function、set 或者 map 等都会对构造函数产生影响，实例化对象后会返回该引用类型

```js
function Car1() {
  this.wheel = 4;
  return [2];
}
function Car2() {
  this.wheel = 4;
  return new Set(1);
}
function Car3() {
  this.wheel = 4;
  return new Map(["a", 1]);
}
function Car4() {
  this.wheel = 4;
  return function () {};
}
const car1 = new Car1();
const car2 = new Car2();
const car3 = new Car3();
const car4 = new Car4();
console.log(car1); // [2]
console.log(car2); // Set(1) {1}
console.log(car3); // Map(1) {"a" => 1}
console.log(car4); // ƒ (){}
```

不过，返回值引用的类型，对构造函数是没有任何影响的，实例化对象返回空对象
