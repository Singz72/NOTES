理解原型对象，主要就是理解protptype、constructor和__proto__

对于一个构造函数，
它能够通过protptype属性找到它的原型对象的位置。

举个例子，现在先建一个构造函数

```js
function Question(a){
    this.a = a;
}
```

即Question.prototype指向Question的原型对象，记住这是指向，是一个指针。
现在再由该构造函数生成一个实例对象

```js
var question = new Question('a');
```

该实例对象具有一个__proto__属性，question可以通过该属性找到自身的原型对象。
所有的对象都具有__protp__属性，但只有函数才具有prototype属性，说的准确些，
就是所有的实例对象都一个[[Prototype]]属性，指向原型对象，这是一个隐式的属性，存在但我们无法访问，
但是浏览器厂商大部分都支持一个__proto__属性，用来显示的指向原型对象，虽然能够用，但___proto__属性不属于ECMA规范。
所以可以得到

```js
Question.prototype === question.__proto__  //true
```

对于原型对象，它拥有一个constructor属性，指向该原型对象的构造函数

```js
Question.prototyoe.constructor === Question //true
```

所以当实例在调用constructor属性时，因为实例本身是没有这个属性的，
所以就会往它的原型对象上去寻找，而它的原型对象的constructor属性指向的正是构造函数

```js
Questionquestion.constructor === Question //true
```

再者，构造函数的原型对象也是一个对象，可以归结为是Object的一个实例，
所以Question.prototype也有一个__proto__属性指向它的原型对象Object.prototype，
而Object.prototype的constructor属性指向的就是Object。
同理Object.prototype也是一个实例对象，可是它的原型对象

```js
Object.prototype.__proto__ === null //true
```

这已经到达原型链最顶端了，跟着链子走，最后却是一场null不由得想到一句话万物皆虚，万事皆允

正如JS中万物皆对象所以说会Question这个构造函数，函数本身也是一个对象，所以Question也应该是拥有一个__proto__属性指向它的原型对象的，
即Function.prototype同理，Function.prototype也是具备一个__proto__属性指向它的原型对象的，
但这里指向的就直接是Object.prototype，即

```js
Fucntion.prototype.__proto__  === Object.prototype //true
```

上面也说过，只有函数才具备prototype属性，所以Function和Object都可以构造函数，
且应该都具备一个__proto__属性指向它们的原型对象，即

```js
Object.__proto__ === Fucntion.prototype; //true
Function.__proto__ === Function.prototype; //true
```
